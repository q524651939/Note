---
typora-root-url: ..\..\Picture
---

## 16位寄存器

16位的CPU：

1KB=1024B

内存寻址地址：0x0000~0xFFFF  64K

16位寄存器可以寻找2^16个内存单元  也就是65535加个0000就是65536 

就是一共可以放65536个不同的地址

一个地址的内存放一个字节（Byte）

 65536 /1024=64K

换句话说在16位的CPU中 内存条最多用64K

同理 32位CPU最多支持 2^32/1024/1024/1024=4G内存

​						      K     M      G

64位CPU支持16777216T的内存

16位的CPU就表示有16根线  每根线控制01



## 分段的概念



如果要一个16位的CPU表示一个20位的地址  可以采用两个16位寄存器结合地址加法器来达到效果



16 16 ==》 20位内存地址



假设一个20个G的文件，但是文件指针只有32位 就表示文件指针最多指4G的内存

引用多次该文件指针 4G 4G  引用5次  就是5个段

通过段寄存器加上偏移地址 来表示一个大的内存地址

打个比方： 

为什么16的倍数一定末尾是四个零 所以不用去考虑末四位

因为 16的十进制转16进制就是10  转成2进制 10000

![1660207292489](/1660207292489.jpg)

![1660206016338](/1660206016338.jpg)

分段后用户编程时，采用逻辑地址，形成为

逻辑地址：段+偏移

段基地址：段内偏移地址

cs:ip  ==》 20位的物理地址 cs<<4 +ip        cs左移4位加上ip地址

例：
要访问一个0x12345物理地址

cs=0x1234      ||  cs=0x1000

ip=5                 || ip=0x2345

1234:5             || 1000:2345

得出一个结论：一个物理地址对应多个逻辑地址

一个段最小16个字节，64位

1234:5如下                                        左移四位

0001 0010 0011 0100  | 0001 0010 0011 0100 0000   + 0101 = 0001 0010 0011 0100 0101 =0x12345

1000:2345如下

0001 0000 0000 0000 | 0001 0000 0000 0000 0000 + 0010 0011 0100 1001 =

0001 0010 0011 0100 1001 = 0x12345

 再来举个例子：0AE3:0100

0000 1011 1110 0011 | 0000 1011 1110  0010 0000 + 0000 0001 0000 0000 =

0000 1011 1111 0011 0000 = 0x0AF30

所以在物理地址上： 0AE3:0100 = 0:AF30

再来举个例子：0B21:0100

0000 1100 0010 0001 | 0000 1100 0010 0001 0000 + 0000 0001 0000 0000 = 

0000 1100 0011 0001 0000 = 0x0B310

所以在物理地址上： 0B21:0100 = 0:B310

![1660209496028](/1660209496028.jpg)

可以观察给CS和IP复制后，-u默认拿CS当段地址，IP当偏移

![image-20220811174139455](/image-20220811174139455.png)

如果输入 -u 2000 默认段时100  偏移变成2000

![image-20220811174251114](/image-20220811174251114.png)
